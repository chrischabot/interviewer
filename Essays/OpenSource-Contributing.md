# “Please Don’t Start With a Refactor”: What Open Source Maintainers Really Want From Your PRs

## Open source from the other side of the PR

I’ve been on both sides of this now. I was literally a really dumb college kid playing with my Neovim config who just wanted my status line to look different, and I had no idea how anything worked, and I didn’t even understand what open source was. I remember opening my browser and it works, I clicked around, looked up to these projects and maintainers, and I really, really wanted to be like a Rails contributor or to contribute to some big name thing because it felt like that was the path to “I did open source and now I have this super cool job.”  

The way I actually got involved with open source was a lot less glamorous than the story you usually hear, and a lot more like, *“Hey, I’d like to work on this, I don’t know how to do the code style things for this, what do you guys do?”* and then someone said, *“You can go check out this file, you can go do this stuff, research the problem, look at this file, try and figure out what can happen.”* That same person came in and helped me in the PR and then eventually we had, you know, telescope initially for Neovim, it eventually got merged into Neovim and that was my first contribution, which then jump‑started me.  

That one pull request was not some heroic refactor or a massive reimagining of how some entire subsystem works; it was a tiny thing, it was *my* pain, and I had helpers in the community coaching me through every step, and that experience ended up changing the trajectory of my career in a lot of ways. Now, I’m on the other side of the PR inbox, and the view looks very different than what I imagined when I was hunting for something to fix just so I could say I had a patch in a big project.  

## Open source is trust, not heroics

Open source is a lot of trust, and that’s the part most people miss when they fire up an LLM or a weekend of “I’m gonna refactor Laravel’s ORM to show how good I am at programming, they’ll really like me after this.” If someone who’s contributed a bunch, has been hanging out in the community, has maintainers and helpers that recognize them, comes in with something substantial, I’m more willing to merge it because I’ll be like, *“Yeah, they’ll follow up if it’s not perfect.”*  

If you just come out swinging and do something big, then it’s really hard for me to dedicate the time to review that, because I’m pretty much assuming I’m going to be maintaining it forever to be honest, and anything can happen and I cannot maintain this forever *for* you. A big refactor as an early thing of *“I’ll show how good I am at programming, they’ll really like me after this”* is a surefire way to get people not happy with the contribution, and drive‑by refactors almost exclusively just end in sadness.  

I’ve lost count of how many times I’ve started a refactor myself and by the time I get to the end I say, *“That’s the same function signature, or I’m in the same spot, or I just ended up in a worse spot that doesn’t handle the 37 edge cases that were there before.”* And that’s *me* in my own code, where I actually know why anything is the way it is, where the method is even put in the code base, why that trade‑off exists. When a stranger shows up with “Refactor X” in the title, it just feels like a bizarre way to try to meet somebody for the first time.  

So we have this sentence in our internal code guide that’s basically *“read the room,”* which is another way of saying open source maturity from a maintainer side is learning how to not let every random PR get to you, but from a contributor side it’s learning not to walk in and say, *“You know what, I know better, I’m going to write this in a new way,”* on your first interaction.  

## Please don’t start with a refactor (or a typo, or new docs)  

There was this trend for like a decade where people said, *“Write documentation, that’s the best way to contribute to open source,”* and I just remember thinking, *please don’t write docs if you’re a brand new user, please don’t fix typos, please don’t do any of that.* If you’re a new user to our project, you’re not expert enough to be teaching every other beginner the project, so like don’t write docs, don’t fix typos, don’t do any of that, it’s kind of just noise that doesn’t matter that much.  

The same goes for drive‑by refactors that are completely disconnected from the rest of the project in terms of the way the code is structured or why certain ugly‑looking pieces exist to handle some nasty long‑tail edge case. A surprising amount of PRs to Laravel come from just people watching other people make PRs, and they see one feature come in and they’re like, *“Oh, it wouldn’t it be neat if this had this feature,”* and it wasn’t driven from any real‑world use case, it was just made up in a vacuum.  

I action PRs really quickly; I have to action like twenty PRs a day or they’re going to get ahead of me, so I just really quickly close those, it’s not even a second thought, and there’s no warranty whatsoever that you’re going to get a comment or an explanation. When the PR title is literally “Refactor X,” or it’s a random code organization or method extraction that has no associated issue, and it’s the first time I’ve ever seen your name, my honest reaction is usually, *“Why would I merge this when this has the potential to make it not work anymore?”*  

So, if you’re new to the project, you don’t know why anything is the way it is, and you don’t actually take the time to look at why the things are in place, then a big refactor as your first contribution is probably the worst possible move you can make.  

## Start with your own pain, not my architecture  

The golden path of the “right way” to contribute to open source, from everything I’ve seen and lived, is pretty boring on the surface: become a user of something, find an issue that you really want fixed, then you be the change to fix that issue and join that community and mess with it. The best thing to do is to kind of get involved in a community around a project you’re actually using, look at your own experience, find a bug that’s actually biting you or a feature that you *really* miss, and start there.  

Most of the features I add to my own stuff are driven out of real‑world need; I try to drive most PRs off of real‑world stuff, and that’s how all the features that people actually like get in. My favorite kind of pull requests are things that maybe add five lines of code but unlock tons of developer power, or a really great new feature flexibility with very minimal code changes to the framework itself, in contrast to huge PRs that modify dozens and dozens of files to unlock one niche edge case for one particular user.  

There’s a huge difference between *“I use this custom keyboard with this custom firmware with like N layers and I only speak Russian but I live in Norway, and my exact setup doesn’t work, please add this branch to your input subsystem,”* and *“I’ve been seeing this bug hit a bunch of people in discussions, it annoys me every single day, I researched it and I think here’s where the problem is.”* Sometimes, the honest answer back is, *“That’s a real issue, but I’m so burnt out on input bugs on Linux that I just don’t want to deal with it again, it’s yours, you need to fix it yourself, the number of people experiencing this issue is so small.”*  

If you find a refactoring opportunity in the ORM of Laravel by firing up some AI and telling it “find me something to refactor,” and you don’t actually use Laravel in a way where you even know if you’re improving anything, it’s made up in a vacuum and it’s going to feel that way to a maintainer. On the other hand, if you say, *“I hit this bug in production, here’s a minimal reproduction, here’s how I think we can fix it, here’s the test,”* that’s like an automatic trust boost; I look at it and think, *“I’m glad this person is around, they’re helping me out.”*  

## The fastest way to earn trust isn’t code  

Something a lot of people miss about this is that if you’re hanging out in the community, you get chances to talk about the feature that you’re really missing before any code gets submitted, and that changes the whole dynamic. Discussions are where maintainers can do feature design, we can bike shed, we can assess whether something’s worth it, we can say, *“I don’t care how you’re going to implement it, what is the config syntax, what is the config name, what does the UI look like with little drawings?”* and then you go off and work on it, come back, and by the time you make it a PR that other maintainer could come in and vouch for you.  

We’ve all been lucky that our open source projects are very widely used, but that also means we have this long tail of angry people and weird expectations where every bug report feels like a demand on our personal life, so we’ve had to build structures around it. In Neovim, Tailwind, Laravel, Ghostty, there are maintainers and there are helpers, and then there’s the rest of the community; helpers answer a lot of Q&A, they tag stuff, label stuff, respond to other people’s issues and explain why it’s their fault instead of me responding to people telling them why it’s their fault.  

In Ghostty, users can only open discussions, then a maintainer or a helper can convert that to an issue, and only maintainers, or someone a maintainer blesses, can open issues, and it avoids all sorts of PRs coming our way that are disconnected from anything real. We have these cool tools called package managers that let you go and build your idea as an external package or plugin and see if it gets traction, which is often a better strategy too; we can say, *“I’m not ready to merge this, go build it as a package and see if it gets traction and then come back.”*  

If you want to earn trust, start where we actually feel the pain: answering questions in discussions, closing issues that are user error, helping with triage, being that person where when your name pops up we think, *“I’m glad this person is around.”* That can be *way* more valuable than dropping a single “impressive” PR as your only contribution, especially if it’s random refactoring or some big change that we never even talked about before you opened it.  

## What maintainers actually look for (and why your own project beats random PRs)

When I’m hiring someone to work on open source with me, or just trying to get a sense of whether I trust their taste, I’m not going through their list of random “Update README” PRs to big projects. If I see someone apply and they’ve created some open source projects, I’m going to go out there and look at everything: how the README is set up, what the config options look like, what the config syntax is, how they think about presenting what they build, all these intangible taste‑type things.  

The README is almost always more high stakes than the code, because it shows the way you think about users, about defaults, about trade‑offs, about what’s important to highlight and what’s not, and that stuff is way harder to fake than a one‑off patch to someone else’s framework. Contributing a random PR to something like Laravel or Tailwind versus just creating something of your own, to me, that second one is like 10x or 20x cooler, because it shows people exactly how you would do things if it were up to you.  

A lot of people hear a story like, *“Oh, I built this open source thing and it got me this dream job,”* and they overvalue the resume bullet of “contributed to famous project,” so they go and refactor Laravel code into a resume and try and leverage that to get a job. The idea of writing perfect code sounds so fun, you’ve read some blog posts that gave you some rules about how long your methods are supposed to be or where things should go, and you show up in a repo you don’t understand and apply those rules like a stencil.  

The one thing we haven’t discussed enough that I think is the most obvious path is just make something yourself; an open source project is something you totally control where you can just like show people the code that you write, show what you’re capable of, show your systems knowledge and taste, especially if you work somewhere where everything’s closed source and under NDA. That perspective of being the person who has to maintain something for years and read angry comments and deal with triage will help you be a better contributor to other projects, because you’ll know exactly what feels helpful and what feels like another rock in the backpack.  

## Slop, AI, and why honesty matters more than the tool  

In the last few months, contributing with LLMs in your toolkit has turned into its own kind of problem, and I’m not anti‑AI, I’ve used Cursor and it actually was able to make something build by just being like, *“I don’t know Zig, I don’t know anything that it did,”* and it figured it out for me and that was nice. I literally spend like $25 a day in AMP tokens, I love it, co‑pilot, whatever, I’m not sitting here saying *never* use AI, I’m saying the problem is when people post slop and they’re really serious about it.  

You can kind of tell what’s going on when you see a PR where it looks like the contributor has fired up Claude or “code something,” said, *“Find a refactor in here,”* and then submitted that PR, and it’s shooting in the dark, disconnected from real‑world use, and half the time you’re pretty sure it’s AI. For me, the best experiences I’ve had with slop in particular are when you’re honest that you have no idea what’s going on, like, *“I used an LLM for this, I’m not confident, please treat it like a suggestion and help me understand,”* because then I know how seriously to take it.  

We require AI disclosure in some of our projects now, and that’s not about policing the tool, it’s because if you can’t be honest about your AI usage, I can’t trust literally anything else you’re doing, so I’m just gonna close this. I would say we catch probably one or two people a week that don’t disclose, and there was one person that super tried to hide it; I eventually got to it, and my reaction at that point is just, *“I will never trust you again.”*  

I have this mental bullet list when I’m reviewing: the quickest way I think, *“This is gonna be some slop,”* is when it’s the first thing you submit to the repo, it’s totally random, and you’re pretending you know what’s going on when you clearly don’t. If you do that enough times, you’re going to ruin your relationships with people; if you do it one time and you’re honest about it and you’re clearly trying to learn, that’s okay, that’s just life, we all use tools. But if you don’t actually debug your way through, don’t try to understand, and you just simply follow whatever the LLM says, you are wasting someone else’s time in a way that’s way more annoying than just not contributing at all.  

So the better way to use AI for contributions is to treat it as a helper while *you* remain responsible: explain in the PR description what you think is going on, what you asked the model to do, where you’re not confident, what tests you ran. I want to know your confidence in what you’re submitting way more than I care exactly which editor or CLI you typed it into, and if you’re candid about that, people will usually meet you halfway.  

## The emotional cost, and why it’s still worth it  

There’s definitely been very dark days in open source; I’ve had stretches where negativity and annoyance and just vitriol have made my life demonstrably worse to the point where it literally distracts from my personal life or my family life. We all probably deal with angry people every day, and I think a big part of surviving as a maintainer is growing some calluses, being willing to let some mean stuff fall off of you, and being mentally prepared that you’re never going to please everybody and some people are just going to think you’re really annoying.  

At one point, that stuff really got me down; I would read every negative thing people said about the project in its nascent years, and it felt like every complaint was a referendum on my ability as a programmer or as a person. Over the last couple of years it really doesn’t bother me at all the way that it used to, and I’ve kind of come around to this combination of, *“I’m not gonna please everyone, that’s okay, and I don’t need to justify anything; if it’s bad enough I’m gonna hear about it, but otherwise I’m going to close my laptop when tab complete is down and go outside.”*  

And yet, if I step back and look at the long term over a period of years, I’ll look back on these times with a lot of fond memories and gratitude; these have been some of the best years of my life. It’s a big privilege to provide these tools that can make people’s professional life a little more enjoyable, to get messages like, *“I’m in Japan and I’m using this,”* or *“This framework made my job better,”* and to work on tools that I use every day myself.  

So, if you want to contribute to open source the “right way,” start by becoming a real user, hang out in the community, answer questions, fix bugs that bite you, and earn trust with small, boring changes that save maintainers time rather than cost them more. And if what you really want is to show what you’re capable of and build your career, don’t underestimate just making something yourself, iterating, maturing, and feeling first‑hand what it’s like when someone shows up in your repo with a random refactor PR titled *“Clean up X.”*  

Once you’ve lived that from the other side of the PR, you’ll never look at your own contributions the same way again.
